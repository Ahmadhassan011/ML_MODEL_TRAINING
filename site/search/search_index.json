{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the Simple ML Pipeline","text":"<p>This project provides a basic, end-to-end machine learning pipeline that demonstrates a simple linear regression model. The pipeline is built with Python and utilizes PyTorch for the model creation and training.</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>The primary goal of this project is to showcase a simple yet complete machine learning workflow, including:</p> <ul> <li>Data Generation: Synthetic data is generated for a linear regression task.</li> <li>Preprocessing: The data is split into training and testing sets.</li> <li>Model Training: A simple linear regression model is trained on the data.</li> <li>Evaluation: The trained model is evaluated on the test set.</li> <li>Prediction: The trained model can be used to make predictions on new data points.</li> <li>Command-Line Interface: A CLI is provided to run the pipeline with different parameters.</li> <li>Documentation: The project is documented using MkDocs, with automatic documentation generation from docstrings.</li> </ul> <p>This project serves as a basic template that can be extended for more complex machine learning tasks.</p>"},{"location":"architecture/","title":"Project Architecture","text":"<p>This page describes the architecture of the Simple ML Pipeline.</p>"},{"location":"architecture/#components","title":"Components","text":"<p>The pipeline is composed of several Python modules, each responsible for a specific part of the workflow.</p> <pre><code>graph TD;\n    A[CLI] --&gt; B(Main);\n    B --&gt; C{Data};\n    B --&gt; D{Preprocessing};\n    B --&gt; E{Model};\n    B --&gt; F{Training};\n    B --&gt; G{Evaluate};\n    B --&gt; H{Predict};\n</code></pre> <ul> <li><code>cli.py</code>: The command-line interface for running the pipeline. It parses command-line arguments and calls the <code>main</code> function.</li> <li><code>main.py</code>: The main entry point of the pipeline. It orchestrates the entire workflow, from data generation to model evaluation and saving.</li> <li><code>data.py</code>: Generates synthetic data for the linear regression model.</li> <li><code>preprocessing.py</code>: Preprocesses the data, including splitting it into training and testing sets.</li> <li><code>model.py</code>: Defines the simple linear regression model using PyTorch.</li> <li><code>training.py</code>: Trains the model using the training data.</li> <li><code>evaluate.py</code>: Evaluates the trained model on the test data.</li> <li><code>predict.py</code>:  Provides a function to make predictions on new data points using the trained model.</li> </ul>"},{"location":"cli/","title":"CLI","text":""},{"location":"cli/#cli","title":"<code>cli</code>","text":""},{"location":"cli/#cli.run","title":"<code>run()</code>","text":"<p>The command-line interface for the machine learning pipeline.</p> Source code in <code>cli.py</code> <pre><code>def run():\n    \"\"\"\n    The command-line interface for the machine learning pipeline.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Run a simple machine learning pipeline.\"\n    )\n    parser.add_argument(\n        \"--n_samples\",\n        type=int,\n        default=100,\n        help=\"Number of samples to generate.\",\n    )\n    parser.add_argument(\n        \"--num_epochs\",\n        type=int,\n        default=100,\n        help=\"Number of epochs to train for.\",\n    )\n    parser.add_argument(\n        \"--learning_rate\",\n        type=float,\n        default=0.01,\n        help=\"Learning rate for the optimizer.\",\n    )\n    args = parser.parse_args()\n\n    main(\n        n_samples=args.n_samples,\n        num_epochs=args.num_epochs,\n        learning_rate=args.learning_rate,\n    )\n</code></pre>"},{"location":"data-flow/","title":"Data Flow","text":"<p>This page describes the data flow within the Simple ML Pipeline.</p>"},{"location":"data-flow/#data-flow-diagram","title":"Data Flow Diagram","text":"<p>The following diagram illustrates how data flows through the different components of the pipeline.</p> <pre><code>sequenceDiagram\n    participant User\n    participant CLI\n    participant Main\n    participant Data\n    participant Preprocessing\n    participant Model\n    participant Training\n    participant Evaluate\n    participant Predict\n\n    User-&gt;&gt;CLI: Run pipeline with parameters\n    CLI-&gt;&gt;Main: Call main function with arguments\n    Main-&gt;&gt;Data: Get synthetic data\n    Data--&gt;&gt;Main: Return X and y\n    Main-&gt;&gt;Preprocessing: Split data into train/test sets\n    Preprocessing--&gt;&gt;Main: Return X_train, y_train, X_test, y_test\n    Main-&gt;&gt;Model: Initialize SimpleRegressionModel\n    Model--&gt;&gt;Main: Return model\n    Main-&gt;&gt;Training: Train model\n    Training--&gt;&gt;Main: Return trained model\n    Main-&gt;&gt;Evaluate: Evaluate model\n    Evaluate--&gt;&gt;Main: Print evaluation results\n    Main-&gt;&gt;Predict: (Optional) Make predictions\n    Predict--&gt;&gt;Main: Return prediction\n</code></pre>"},{"location":"data/","title":"Data","text":""},{"location":"data/#data","title":"<code>data</code>","text":""},{"location":"data/#data.get_data","title":"<code>get_data(n_samples=100)</code>","text":"<p>Generates synthetic data for a simple linear regression model.</p> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>The number of samples to generate.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the features (X) and the target (y).</p> Source code in <code>data.py</code> <pre><code>def get_data(n_samples=100):\n    \"\"\"\n    Generates synthetic data for a simple linear regression model.\n\n    Args:\n        n_samples (int): The number of samples to generate.\n\n    Returns:\n        tuple: A tuple containing the features (X) and the target (y).\n    \"\"\"\n    X = np.random.rand(n_samples, 1) * 10\n    y = 2 * X + 1 + np.random.randn(n_samples, 1) * 2\n    return X, y\n</code></pre>"},{"location":"evaluate/","title":"Evaluate","text":""},{"location":"evaluate/#evaluate","title":"<code>evaluate</code>","text":""},{"location":"evaluate/#evaluate.evaluate_model","title":"<code>evaluate_model(model, X_test, y_test)</code>","text":"<p>Evaluates the trained simple regression model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module</code> <p>The trained model.</p> required <code>X_test</code> <code>Tensor</code> <p>The testing features.</p> required <code>y_test</code> <code>Tensor</code> <p>The testing target.</p> required Source code in <code>evaluate.py</code> <pre><code>def evaluate_model(model, X_test, y_test):\n    \"\"\"\n    Evaluates the trained simple regression model.\n\n    Args:\n        model (torch.nn.Module): The trained model.\n        X_test (torch.Tensor): The testing features.\n        y_test (torch.Tensor): The testing target.\n    \"\"\"\n    model.eval()\n    with torch.no_grad():\n        predicted = model(X_test)\n        criterion = nn.MSELoss()\n        loss = criterion(predicted, y_test)\n        print(f\"Mean Squared Error on test data: {loss.item():.4f}\")\n</code></pre>"},{"location":"main/","title":"Main","text":""},{"location":"main/#main","title":"<code>main</code>","text":""},{"location":"main/#main.main","title":"<code>main(n_samples=100, num_epochs=100, learning_rate=0.01)</code>","text":"<p>The main function to run the machine learning pipeline.</p> Source code in <code>main.py</code> <pre><code>def main(n_samples=100, num_epochs=100, learning_rate=0.01):\n    \"\"\"\n    The main function to run the machine learning pipeline.\n    \"\"\"\n    # Get data\n    X, y = get_data(n_samples)\n\n    # Preprocess data\n    X_train, y_train, X_test, y_test = preprocess_data(X, y)\n\n    # Initialize model\n    input_dim = 1\n    output_dim = 1\n    model = SimpleRegressionModel(input_dim, output_dim)\n\n    # Train model\n    trained_model = train_model(model, X_train, y_train, num_epochs, learning_rate)\n\n    # Evaluate model\n    evaluate_model(trained_model, X_test, y_test)\n\n    # Save the model\n    torch.save(trained_model.state_dict(), \"model.pth\")\n    print(\"Model saved to model.pth\")\n</code></pre>"},{"location":"model/","title":"Model","text":""},{"location":"model/#model","title":"<code>model</code>","text":""},{"location":"model/#model.SimpleRegressionModel","title":"<code>SimpleRegressionModel</code>","text":"<p>               Bases: <code>Module</code></p> <p>A simple linear regression model.</p> Source code in <code>model.py</code> <pre><code>class SimpleRegressionModel(nn.Module):\n    \"\"\"\n    A simple linear regression model.\n    \"\"\"\n    def __init__(self, input_dim, output_dim):\n        \"\"\"\n        Initializes the SimpleRegressionModel.\n\n        Args:\n            input_dim (int): The dimension of the input.\n            output_dim (int): The dimension of the output.\n        \"\"\"\n        super(SimpleRegressionModel, self).__init__()\n        self.linear = nn.Linear(input_dim, output_dim)\n\n    def forward(self, x):\n        \"\"\"\n        The forward pass of the model.\n\n        Args:\n            x (torch.Tensor): The input tensor.\n\n        Returns:\n            torch.Tensor: The output of the model.\n        \"\"\"\n        return self.linear(x)\n</code></pre>"},{"location":"model/#model.SimpleRegressionModel.__init__","title":"<code>__init__(input_dim, output_dim)</code>","text":"<p>Initializes the SimpleRegressionModel.</p> <p>Parameters:</p> Name Type Description Default <code>input_dim</code> <code>int</code> <p>The dimension of the input.</p> required <code>output_dim</code> <code>int</code> <p>The dimension of the output.</p> required Source code in <code>model.py</code> <pre><code>def __init__(self, input_dim, output_dim):\n    \"\"\"\n    Initializes the SimpleRegressionModel.\n\n    Args:\n        input_dim (int): The dimension of the input.\n        output_dim (int): The dimension of the output.\n    \"\"\"\n    super(SimpleRegressionModel, self).__init__()\n    self.linear = nn.Linear(input_dim, output_dim)\n</code></pre>"},{"location":"model/#model.SimpleRegressionModel.forward","title":"<code>forward(x)</code>","text":"<p>The forward pass of the model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input tensor.</p> required <p>Returns:</p> Type Description <p>torch.Tensor: The output of the model.</p> Source code in <code>model.py</code> <pre><code>def forward(self, x):\n    \"\"\"\n    The forward pass of the model.\n\n    Args:\n        x (torch.Tensor): The input tensor.\n\n    Returns:\n        torch.Tensor: The output of the model.\n    \"\"\"\n    return self.linear(x)\n</code></pre>"},{"location":"predict/","title":"Predict","text":""},{"location":"predict/#predict","title":"<code>predict</code>","text":""},{"location":"predict/#predict.main","title":"<code>main()</code>","text":"<p>Loads the model and makes a prediction on a sample data point.</p> Source code in <code>predict.py</code> <pre><code>def main():\n    \"\"\"\n    Loads the model and makes a prediction on a sample data point.\n    \"\"\"\n    # Load the trained model\n    input_dim = 1\n    output_dim = 1\n    model = SimpleRegressionModel(input_dim, output_dim)\n    model.load_state_dict(torch.load(\"model.pth\"))\n\n    # Create a new data point\n    new_data = np.array([5.0])\n\n    # Make a prediction\n    prediction = predict(model, new_data)\n    print(f\"Prediction for input {new_data[0]}: {prediction:.4f}\")\n</code></pre>"},{"location":"predict/#predict.predict","title":"<code>predict(model, data_point)</code>","text":"<p>Makes a prediction on a new data point.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module</code> <p>The trained model.</p> required <code>data_point</code> <code>ndarray</code> <p>The new data point.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The prediction.</p> Source code in <code>predict.py</code> <pre><code>def predict(model, data_point):\n    \"\"\"\n    Makes a prediction on a new data point.\n\n    Args:\n        model (torch.nn.Module): The trained model.\n        data_point (np.ndarray): The new data point.\n\n    Returns:\n        float: The prediction.\n    \"\"\"\n    model.eval()\n    with torch.no_grad():\n        data_tensor = torch.from_numpy(data_point.astype(np.float32))\n        data_tensor = data_tensor.unsqueeze(0) # Add batch dimension\n        prediction = model(data_tensor)\n        return prediction.item()\n</code></pre>"},{"location":"preprocessing/","title":"Preprocessing","text":""},{"location":"preprocessing/#preprocessing","title":"<code>preprocessing</code>","text":""},{"location":"preprocessing/#preprocessing.preprocess_data","title":"<code>preprocess_data(X, y)</code>","text":"<p>Preprocesses the data by splitting it into training and testing sets and converting it to PyTorch tensors.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The features.</p> required <code>y</code> <code>ndarray</code> <p>The target.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the training and testing data as PyTorch tensors.</p> Source code in <code>preprocessing.py</code> <pre><code>def preprocess_data(X, y):\n    \"\"\"\n    Preprocesses the data by splitting it into training and testing sets and\n    converting it to PyTorch tensors.\n\n    Args:\n        X (np.ndarray): The features.\n        y (np.ndarray): The target.\n\n    Returns:\n        tuple: A tuple containing the training and testing data as PyTorch tensors.\n    \"\"\"\n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=0.2, random_state=42\n    )\n\n    X_train_tensor = torch.from_numpy(X_train.astype(np.float32))\n    y_train_tensor = torch.from_numpy(y_train.astype(np.float32))\n    X_test_tensor = torch.from_numpy(X_test.astype(np.float32))\n    y_test_tensor = torch.from_numpy(y_test.astype(np.float32))\n\n    return X_train_tensor, y_train_tensor, X_test_tensor, y_test_tensor\n</code></pre>"},{"location":"training/","title":"Training","text":""},{"location":"training/#training","title":"<code>training</code>","text":""},{"location":"training/#training.train_model","title":"<code>train_model(model, X_train, y_train, num_epochs=100, learning_rate=0.01)</code>","text":"<p>Trains the simple regression model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module</code> <p>The model to train.</p> required <code>X_train</code> <code>Tensor</code> <p>The training features.</p> required <code>y_train</code> <code>Tensor</code> <p>The training target.</p> required <code>num_epochs</code> <code>int</code> <p>The number of epochs to train for.</p> <code>100</code> <code>learning_rate</code> <code>float</code> <p>The learning rate for the optimizer.</p> <code>0.01</code> <p>Returns:</p> Type Description <p>torch.nn.Module: The trained model.</p> Source code in <code>training.py</code> <pre><code>def train_model(model, X_train, y_train, num_epochs=100, learning_rate=0.01):\n    \"\"\"\n    Trains the simple regression model.\n\n    Args:\n        model (torch.nn.Module): The model to train.\n        X_train (torch.Tensor): The training features.\n        y_train (torch.Tensor): The training target.\n        num_epochs (int): The number of epochs to train for.\n        learning_rate (float): The learning rate for the optimizer.\n\n    Returns:\n        torch.nn.Module: The trained model.\n    \"\"\"\n    criterion = nn.MSELoss()\n    optimizer = optim.SGD(model.parameters(), lr=learning_rate)\n\n    for epoch in range(num_epochs):\n        model.train()\n\n        # Forward pass\n        outputs = model(X_train)\n        loss = criterion(outputs, y_train)\n\n        # Backward and optimize\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n        if (epoch + 1) % 10 == 0:\n            print(f\"Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}\")\n\n    return model\n</code></pre>"}]}